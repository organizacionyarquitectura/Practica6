
% tipo de documento
\documentclass{article}

% formato de página
\usepackage[margin=1.5cm, letterpaper]{geometry}

% idioma de los macros
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}

% vínculos
\usepackage{hyperref}

% manejo de ecuaciones
\usepackage{amsmath}

% texto del documento
\begin{document}
    \title{
        Organización y Arquitectura de Computadoras \\
        Práctica 6: Lenguaje ensamblador \\
    }
    \date{
        31 de marzo del 2019
    }
    \author{
        Sandra del Mar Soto Corderi \\
        Edgar Quiroz Castañeda
    }
    \maketitle

    \section{Preguntas}
    \begin{enumerate}
        \item {
        	A partir del ejercicio 4:
            \[4\cdot\sum_{n=0}^{m}{\frac{(-1)^{n}}{2n+1}}\]
            \begin{enumerate}
                \item ¿A qué valor tiende la serie?\\
                Es la fórmula de Leibniz\cite{wolfram pi} para aproximar $\pi$.\\
                
                \item ¿A cuántos dígitos se puede aproximar ese valor?
                Como es precisión sencilla, se pueden aproximar hasta 23 bits
                del valor en binario, que equivalen a 7 dígitos de precisión en
                decimal\cite{ieee flot32 std}.\\
                
                \item ¿Cuántas iteraciones son necesarias para llegar a esa
                aproximación?               
                Los primeros 7 dígitos de $\pi$ son 3.141592\cite{pi dig}.\\
                Redondeando el número, se puede llegar a esa precisión después
                de 1421283 iteraciones,  con la aproximación 3.141591950000691. \\
                Sin redondear, se llega a el en 1530011 iteraciones con la
                aproximación 3.141592000000233.\\
                A partir de 2886750 iteraciones, se tiene que todos las
                aproximaciones tienen los primeros 7 dígitos correctos.\\
                Pudimos obtener estos valores a partir de programas creados en python bajo el nombre de leibniz en la carpeta python.
            \end{enumerate}
        }
        \item ¿Existe alguna diferencia en escribir programas en lenguaje 
        ensamblador comparado con escribir programas en lenguajes de alto nivel?\\
        
        Escribir programas de alto nivel permite abstraer e implementar conceptos
        sin necesidad de tener en cuenta la traducción a código máquina, lo que
        hace que se pueda ignorar toda la parte física de la computadora.
        \item ¿En qué casos es preferible escribir programas en lenguaje 
        ensamblador y en qué casos es preferible hacerlo con un lenguaje de alto
        nivel?\\
        
        Al depender de la arquitectura de la computadora, el código en lenguaje
        ensamblador no es portable, además de que requiere conocimiento de la
        máquina particular con la se está trabajando. Sin embargo, el código
        producido es los más eficaz posible.\\
        Entonces, se debería usar ensamblador cuando se esté diseñando código
        específico de hardware que requiere ser muy eficaz, como lo requieren
        algunos compiladores o ciertos fragmentos de sistemas operativos.
        
    \end{enumerate}

    \begin{thebibliography}{1}
        \bibitem{ieee flot32 std} 
        \textit{IEEE Standard for Floating-Point Arithmetic},
        IEEE Std 754-2008, 2008. [Online]. Disponible: 
        \url{https://ieeexplore.ieee.org/document/4610935}.
        [Consultado: 28-Mar-2019].
        
        \bibitem{wolfram pi}
        E. W. Weisstein, \textit{Pi Formulas}, Wolfram MathWorld. [Online]. 
        Disponible: \url{http://mathworld.wolfram.com/PiFormulas.html}.
        [Consultado: 28-Mar-2019].

        \bibitem{pi dig}
        M. Huberty, K. Hayashi and C. Vang, \textit{100,000 Digits of Pi}, 
        Geom.uiuc.edu, 1997. [Online]. Disponible: 
        \url{http://www.geom.uiuc.edu/~huberty/math5337/groupe/digits.html}. 
        [Consultado: 28-Mar-2019]
    \end{thebibliography}
\end{document}